/*
 * Copyright (C) 2012-2014 by various contributors (see doc/ACORN_AUTHORS)
 * Copyright (C) 2015 Jordan Klassen <forivall@gmail.com>
 *
 * See LICENSE for full license text
 */

// These two files are autogenerated by packages/horchata/bin/generate-identifier-regex.js

// regarding the codes:
// These are a run-length and offset encoded representation of the
// >0xffff code points that are a valid part of identifiers. The
// offset starts at 0x10000, and each pair of numbers represents an
// offset to the next range, and then a size of the range. They were
// generated by tools/generate-identifier-regex.js
import {nonASCIIidentifierStartChars, astralIdentifierStartCodes} from "./_identifierStartData";
import {nonASCIIidentifierChars, astralIdentifierCodes} from "./_identifierContData";

// ## Keywords & reserved words
// Other than eval and arguments, all of these words are treated as keywords in
// tacoscript, and when used (in a valid context) as a variable name
// (identifier), will have the prefix `\$`

export const reservedWords = {
  es2015: ["enum", "await"],
  strict: [
    "implements", "interface", "let", "package",
    "private", "protected", "public", "static", "yield"
  ],
  strictBind: ["eval", "arguments"],
  keywords: [
    "break", "case", "catch", "continue", "debugger", "default", "do", "else",
    "finally", "for", "function", "if", "return", "switch", "throw", "try",
    "var", "with", "true", "false", "instanceof", "typeof", "void", "delete",
    "new", "in", "this", "let", "const", "class", "extends", "export", "import",
    "yield", "super"],
  tacoscript: [] // will be populated below
}

export const keywords = reservedWords.keywords;

import {keywords as keywordTokens} from "../tokenizer/types";

for (let keyword in keywordTokens) {
  if (keywords.indexOf(keyword) < 0) {
    reservedWords.tacoscript.push(keyword);
  }
}

// ## Character categories

const nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
const nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

// This has a complexity linear to the value of the code. The
// assumption is that looking up astral identifier characters is
// rare.
function isInAstralSet(code, set) {
  let pos = 0x10000;
  for (let i = 0; i < set.length; i += 2) {
    pos += set[i];
    if (pos > code) return false;

    pos += set[i + 1];
    if (pos >= code) return true;
  }
}

// Test whether a given character code starts an identifier.

export function isIdentifierStart(code) {
  if (code < 65) return code === 36;
  if (code < 91) return true;
  if (code < 97) return code === 95;
  if (code < 123) return true;
  if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
  return isInAstralSet(code, astralIdentifierStartCodes);
}

// Test whether a given character is part of an identifier.

export function isIdentifierChar(code) {
  if (code < 48) return code === 36;
  if (code < 58) return true;
  if (code < 65) return false;
  if (code < 91) return true;
  if (code < 97) return code === 95;
  if (code < 123) return true;
  if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
}

export function codePointToString(code) {
  // UTF-16 Decoding
  if (code <= 0xFFFF) return String.fromCharCode(code)
  code -= 0x10000
  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)
}
